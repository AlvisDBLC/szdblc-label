<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>川丞物料标签生成</title>
  <style>
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans SC","PingFang SC","Microsoft YaHei",Arial; padding:24px; background:#0b0b0b; color:#eaeaea;}
    .wrap{max-width:1100px;margin:0 auto;}
    h1{font-size:18px;margin:0 0 14px;font-weight:650;}
    .top-actions{display:flex;gap:10px;align-items:center;margin:12px 0 14px;flex-wrap:wrap;}
    .btn{cursor:pointer;border:1px solid #444;background:#151515;color:#fff;padding:10px 12px;border-radius:10px;}
    .btn:hover{border-color:#666;}
    .hint{color:#9aa;font-size:12px}
    table{width:100%;border-collapse:collapse;background:#121212;border:1px solid #2a2a2a;border-radius:12px;overflow:hidden;}
    th,td{border-bottom:1px solid #222;padding:10px;vertical-align:top;}
    th{font-weight:600;text-align:left;color:#bbb;font-size:12px;}
    input{width:100%;box-sizing:border-box;border:1px solid #333;background:#0f0f0f;color:#fff;padding:8px 10px;border-radius:10px;}
    .row-actions{display:flex;gap:8px;}
    .small{font-size:12px;color:#9aa;line-height:1.4}
    .card{border:1px solid #2a2a2a;border-radius:12px;padding:12px;background:#101010;margin-bottom:14px;}
  </style>

  <!-- jsPDF (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
</head>
<body>
<div class="wrap">
  <h1>川丞物料标签生成（10×10cm / 内容 7×7cm / 多页 PDF）</h1>

    <div class="card">
    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
      <b style="font-size:13px;">共享历史</b>
      <input id="hisQ" placeholder="搜索 物料编码/名称" style="max-width:280px;">
      <button class="btn" id="hisRefresh">刷新</button>
      <button class="btn" id="hisSaveNew">保存为新记录</button>
      <button class="btn" id="hisSaveOverwrite" disabled>覆盖保存</button>
      <span class="hint" id="hisTip">未加载任何历史记录</span>
    </div>
    <div id="hisList" style="margin-top:10px; display:flex; flex-direction:column; gap:8px;"></div>
  </div>


  <div class="top-actions">
    <button class="btn" id="addRow">新增一张标签</button>
    <button class="btn" id="makePdf">生成 PDF 并下载</button>
    <span class="hint">可一次生成几十张，下载仍然只有一个 PDF（多页）。</span>
  </div>

  <table>
    <thead>
      <tr>
        <th style="width:14%">物料编码</th>
        <th style="width:22%">物料名称</th>
        <th style="width:10%">数量</th>
        <th style="width:14%">订单编码</th>
        <th style="width:14%">送货日期</th>
        <th style="width:12%">包装数量</th>
        <th style="width:14%">操作</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>
</div>

<script>
  const tbody = document.getElementById('tbody');
  const statusEl = document.getElementById('fontLoadStatus');
  const { jsPDF } = window.jspdf;

  // ===== 共享历史（Workers + D1）配置 =====
const API_BASE = "https://label-api.alvis-8fc.workers.dev";
let loadedLabelId = null; // 当前加载的历史记录ID（用于覆盖保存）

function getWriteKey() {
  // 不把口令写死在源码里：每个同事首次保存时输入一次即可
  const k = localStorage.getItem("label_write_key");
  if (k) return k;
  const input = prompt("请输入写入口令（仅首次需要）：");
  if (!input) return null;
  localStorage.setItem("label_write_key", input.trim());
  return input.trim();
}

async function apiGet(path) {
  const r = await fetch(`${API_BASE}${path}`);
  if (!r.ok) throw new Error(`GET ${path} failed`);
  return r.json();
}
async function apiPost(path, body) {
  const key = getWriteKey();
  if (!key) throw new Error("no_write_key");
  const r = await fetch(`${API_BASE}${path}`, {
    method: "POST",
    headers: { "Content-Type": "application/json", "X-Write-Key": key },
    body: JSON.stringify(body),
  });
  if (!r.ok) throw new Error(`POST ${path} failed`);
  return r.json();
}
async function apiDelete(path) {
  const key = getWriteKey();
  if (!key) throw new Error("no_write_key");
  const r = await fetch(`${API_BASE}${path}`, {
    method: "DELETE",
    headers: { "X-Write-Key": key },
  });
  if (!r.ok) throw new Error(`DELETE ${path} failed`);
  return r.json();
}


  // === 自动加载字体（一次缓存，多次复用）===
  const FONT_URL = "./assets/fonts/NotoSansSC-Regular.ttf";
  let cachedFontBase64 = null;

  async function loadFontBase64(url) {
    const resp = await fetch(url, { cache: "force-cache" });
    if (!resp.ok) throw new Error("Font download failed: " + resp.status);
    const buf = await resp.arrayBuffer();
    let binary = '';
    const bytes = new Uint8Array(buf);
    const chunkSize = 0x8000;
    for (let i = 0; i < bytes.length; i += chunkSize) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
    }
    return btoa(binary);
  }

  async function ensureFontLoaded() {
    if (cachedFontBase64) return cachedFontBase64;
    statusEl.textContent = "字体状态：正在加载…（首次可能稍等 1–3 秒）";
    cachedFontBase64 = await loadFontBase64(FONT_URL);
    statusEl.textContent = "字体状态：已加载（中文 PDF 正常）";
    return cachedFontBase64;
  }

  // ---- 表格行 ----
  function newRow(prefill = {}) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input placeholder="手填" value="${prefill.material_code || ''}"></td>
      <td><input placeholder="手填" value="${prefill.material_name || ''}"></td>
      <td><input placeholder="手填" value="${prefill.qty || ''}"></td>
      <td><input placeholder="手填" value="${prefill.order_code || ''}"></td>
      <td><input placeholder="手填" value="${prefill.deliver_date || ''}"></td>
      <td><input placeholder="手填" value="${prefill.pack_qty || ''}"></td>
      <td>
        <div class="row-actions">
          <button class="btn" data-act="dup">复制</button>
          <button class="btn" data-act="del">删除</button>
        </div>
      </td>
    `;
    tr.addEventListener('click', (e) => {
      const act = e.target?.getAttribute?.('data-act');
      if (!act) return;
      if (act === 'del') tr.remove();
      if (act === 'dup') newRow(getRowData(tr));
    });
    tbody.appendChild(tr);
  }

  function getRowData(tr) {
    const inputs = tr.querySelectorAll('input');
    return {
      material_code: inputs[0].value.trim(),
      material_name: inputs[1].value.trim(),
      qty: inputs[2].value.trim(),
      order_code: inputs[3].value.trim(),
      deliver_date: inputs[4].value.trim(),
      pack_qty: inputs[5].value.trim(),
    };
  }

  document.getElementById('addRow').onclick = () => newRow();

  // ---- 画一页标签：10x10cm(=100x100mm)；内容框7x7cm(=70x70mm) ----
  function drawLabel(doc, data) {
    const pageW = 100, pageH = 100;      // mm
    const boxW = 85, boxH = 85;          // mm
    const left = (pageW - boxW) / 2;
    const top = (pageH - boxH) / 2;

    // 白底
    doc.setFillColor(255,255,255);
    doc.rect(left, top, boxW, boxH, 'F');

    // 黑框
    doc.setDrawColor(0,0,0);
    doc.setLineWidth(0.8);
    doc.rect(left, top, boxW, boxH, 'S');

    // 标题
    doc.setFontSize(18);
    doc.text("川丞物料", pageW/2, top + 10, { align: "center" });

    // 字段
    doc.setFontSize(12);
    const rows = [
      ["物料编码", data.material_code || ""],
      ["物料名称", data.material_name || ""],
      ["数    量", data.qty || ""],
      ["订单编码", data.order_code || ""],
      ["送货日期", data.deliver_date || ""],
      ["包装数量", data.pack_qty || ""],
    ];

    const labelX = left + 4;
    const colonX = left + 22;
    const lineX1 = left + 28;
    const lineX2 = left + boxW - 4;

    let y = top + 24;
    const gap = 10.5;

    doc.setLineWidth(0.5);

    for (const [lab, val] of rows) {
      doc.text(lab, labelX, y);
      doc.text("：", colonX, y);

      // 下划线
      doc.line(lineX1, y + 1.2, lineX2, y + 1.2);

      // 预填内容（如果你希望“只留线不打印文字”，把这行注释掉）
      if (val) doc.text(String(val), lineX1 + 2, y);

      y += gap;
    }
  }

  document.getElementById('makePdf').onclick = async () => {
  const rows = [...tbody.querySelectorAll('tr')];
  if (rows.length === 0) {
    alert('请先新增至少一张标签');
    return;
  }

  // === 1. 先生成 PDF（最高优先级） ===
  let items;
  try {
    const doc = new jsPDF({ unit: 'mm', format: [100, 100] });

    const fontBase64 = await ensureFontLoaded();
    doc.addFileToVFS("CNFont.ttf", fontBase64);
    doc.addFont("CNFont.ttf", "CNFont", "normal");
    doc.setFont("CNFont", "normal");

    items = rows.map(tr => getRowData(tr));

    items.forEach((data, idx) => {
      if (idx > 0) doc.addPage([100, 100], 'portrait');
      drawLabel(doc, data);
    });

    doc.save("labels.pdf");
  } catch (e) {
    console.error(e);
    alert("生成 PDF 失败（可能是字体或浏览器问题），请刷新页面后重试。");
    return; // PDF 都失败了，直接结束
  }

  // === 2. 再尝试保存共享历史（失败不影响打印） ===
  try {
    await apiPost("/labels", { items });
  } catch (e) {
    console.warn("保存共享历史失败：", e);
    alert(
      "PDF 已成功生成。\n\n但【共享历史保存失败】（可能是写入口令未输入或网络问题）。\n" +
      "不影响本次打印，下次可刷新后重试保存。"
    );
  }

  // 刷新历史列表（不强制）
  refreshHistory().catch(() => {});
};


  // 默认 1 行
  newRow();
  // ===== 共享历史 UI =====
const hisQ = document.getElementById("hisQ");
const hisRefresh = document.getElementById("hisRefresh");
const hisSaveNew = document.getElementById("hisSaveNew");
const hisSaveOverwrite = document.getElementById("hisSaveOverwrite");
const hisList = document.getElementById("hisList");
const hisTip = document.getElementById("hisTip");

function setTip(text) {
  hisTip.textContent = text;
}

function collectCurrentItems() {
  const trs = [...tbody.querySelectorAll("tr")];
  return trs.map(tr => getRowData(tr));
}

function replaceTableWithItems(items) {
  tbody.innerHTML = "";
  items.forEach(it => newRow(it));
  if (items.length === 0) newRow();
}

function makeHisRow(item) {
  const div = document.createElement("div");
  div.style.border = "1px solid #2a2a2a";
  div.style.borderRadius = "10px";
  div.style.padding = "10px";
  div.style.background = "#0f0f0f";
  div.style.display = "flex";
  div.style.justifyContent = "space-between";
  div.style.alignItems = "center";
  div.style.gap = "10px";

  const left = document.createElement("div");
  left.innerHTML = `
    <div style="font-size:13px; font-weight:650;">
      ${escapeHtml(item.material_code || "(无编码)")} — ${escapeHtml(item.material_name || "(无名称)")}
    </div>
    <div class="hint">更新时间：${escapeHtml(item.updated_at || "")}</div>
  `;

  const right = document.createElement("div");
  right.style.display = "flex";
  right.style.gap = "8px";

  const btnLoad = document.createElement("button");
  btnLoad.className = "btn";
  btnLoad.textContent = "加载";
  btnLoad.onclick = async () => {
    const data = await apiGet(`/labels/${item.id}`);
    loadedLabelId = data.label.id;
    replaceTableWithItems(data.items || []);
    hisSaveOverwrite.disabled = false;
    setTip(`已加载记录：${loadedLabelId}（可覆盖保存）`);
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  const btnDel = document.createElement("button");
  btnDel.className = "btn";
  btnDel.textContent = "删除";
  btnDel.onclick = async () => {
    if (!confirm("确定删除这条共享历史记录？")) return;
    await apiDelete(`/labels/${item.id}`);
    if (loadedLabelId === item.id) {
      loadedLabelId = null;
      hisSaveOverwrite.disabled = true;
      setTip("已删除当前加载的记录");
    }
    await refreshHistory();
  };

  right.appendChild(btnLoad);
  right.appendChild(btnDel);

  div.appendChild(left);
  div.appendChild(right);
  return div;
}

function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

async function refreshHistory() {
  const q = (hisQ.value || "").trim();
  const data = await apiGet(`/labels?limit=50${q ? `&q=${encodeURIComponent(q)}` : ""}`);
  hisList.innerHTML = "";
  (data.items || []).forEach(it => hisList.appendChild(makeHisRow(it)));
  if ((data.items || []).length === 0) {
    const empty = document.createElement("div");
    empty.className = "hint";
    empty.textContent = "暂无共享历史记录";
    hisList.appendChild(empty);
  }
}

hisRefresh.onclick = refreshHistory;
hisQ.addEventListener("keydown", (e) => {
  if (e.key === "Enter") refreshHistory();
});

hisSaveNew.onclick = async () => {
  const items = collectCurrentItems();
  await apiPost("/labels", { items }); // 不传 id => 新记录
  loadedLabelId = null;
  hisSaveOverwrite.disabled = true;
  setTip("已保存为新记录");
  await refreshHistory();
};

hisSaveOverwrite.onclick = async () => {
  if (!loadedLabelId) return;
  const items = collectCurrentItems();
  await apiPost("/labels", { id: loadedLabelId, items }); // 传 id => 覆盖
  setTip(`已覆盖保存：${loadedLabelId}`);
  await refreshHistory();
};

// 页面打开先拉一次共享历史
refreshHistory().catch(()=>{});

</script>
</body>
</html>





